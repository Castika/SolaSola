from music21 import environment, converter, note, chord, meter, key, tempo, metadata, stream
from pathlib import Path
import io
import subprocess
import os
import traceback

def _post_process_abc_content(abc_text: str, title: str) -> str:
    """
    Cleans up the raw output from the midi2abc tool.
    - Sets the correct title (T:) field.
    - Removes analytical comments from midi2abc (e.g., "% Last note suggests...").
    - Removes duplicate MIDI program directives within a single voice to clean up the output.
    """
    lines = abc_text.splitlines()
    cleaned_lines = []
    seen_midi_program_in_voice = False

    for line in lines:
        # The midi2abc tool generates a default title from the filename.
        # This line overwrites it with the desired, user-friendly title.
        if line.startswith('T:'):
            cleaned_lines.append(f'T: {title}')
            continue
        
        # These analytical comments from midi2abc are not useful for the end-user,
        # so we remove them to keep the score clean.
        if line.strip().startswith('% Last note suggests'):
            continue

        # A voice only needs one MIDI program directive. This block ensures we keep
        # the first one and discard any subsequent duplicates within the same voice.
        if line.strip().startswith('V:'):
            seen_midi_program_in_voice = False
        if line.strip().startswith('%%MIDI program'):
            if not seen_midi_program_in_voice:
                seen_midi_program_in_voice = True
                cleaned_lines.append(line)
            continue
        
        cleaned_lines.append(line)
    
    return '\n'.join(cleaned_lines)

def convert_midi_to_abc(midi_paths: list, song_title: str) -> dict[str, str] | None:
    """
    Converts a list of MIDI files into a dictionary of ABC notation strings,
    one for each instrument part.
    Lyrics are intentionally not processed here; they are merged into the final output in a later step.

    Args:
        midi_paths (list): A list of paths to the input MIDI files.
        song_title (str): The title of the song for the ABC header.

    Returns:
        A dictionary mapping instrument names to their ABC notation strings, or None on failure.
    """
    # music21 sometimes needs to write temporary files. To prevent permission errors
    # inside the Docker container (where the app directory might not be writable by the user),
    # we explicitly set its scratch directory to the universally writable '/tmp' folder.
    us = environment.UserSettings()
    us['directoryScratch'] = '/tmp'
    
    print(f"\nStarting per-instrument MIDI to ABC conversion for: {song_title}")
    temp_dir = Path(us['directoryScratch'])

    abc_results = {}

    # Process each MIDI file as a separate instrument part.
    for midi_path in midi_paths:
        part_name = Path(midi_path).stem
        part_title = f"{song_title} ({part_name})" # e.g., "My Song (Bass)"
        print(f"  -> Processing part: {part_name}.mid")
        
        temp_midi_path = temp_dir / f"{part_title}.mid"
        temp_abc_path = temp_dir / f"{part_title}.abc"

        try:
            score_part = converter.parse(midi_path, forceSource=True)
            if not score_part or not score_part.flatten().notesAndRests:
                print(f"    -> Warning: MIDI file {Path(midi_path).name} is empty or invalid. Skipping.")
                continue

            # To ensure a clean conversion for each part, we create a new, temporary
            # music21 Score object that contains only this single instrument part.
            single_part_score = stream.Score()
            single_part_score.insert(0, metadata.Metadata())
            single_part_score.metadata.title = part_title
            score_part.parts[0].id = part_name # Assign an ID to the part.
            single_part_score.insert(0, score_part.parts[0])

            # 1. Write this single-part score to a temporary MIDI file.
            single_part_score.write('midi', fp=str(temp_midi_path))

            # 2. Use the external 'midi2abc' command-line tool. It is generally more
            #    robust and provides better formatting than music21's built-in ABC converter.
            cmd = ['midi2abc', str(temp_midi_path), '-o', str(temp_abc_path)]
            result = subprocess.run(cmd, capture_output=True, text=True, check=False)

            if result.returncode != 0:
                print(f"  -> ERROR: midi2abc command failed for {part_name}. Stderr: {result.stderr}")
                continue

            # 3. Read the resulting ABC file generated by the tool.
            if not temp_abc_path.exists() or temp_abc_path.stat().st_size == 0:
                print(f"  -> ERROR: midi2abc did not create a valid ABC file for {part_name}.")
                continue
            
            with open(temp_abc_path, 'r', encoding='utf-8') as f:
                abc_text_content = f.read()

            # Clean up the raw ABC output before storing it.
            abc_results[part_name] = _post_process_abc_content(abc_text_content, part_title)
            print(f"  -> Successfully converted {part_name} to ABC.")

        except Exception as e:
            print(f"  -> An error occurred during ABC conversion for {part_name}: {e}")
            traceback.print_exc()
        finally:
            # Clean up the temporary files created for this specific part.
            if temp_midi_path.exists():
                os.remove(temp_midi_path)
            if temp_abc_path.exists():
                os.remove(temp_abc_path)

    return abc_results if abc_results else None

def generate_mix_abc(mix_midi_path: str, song_title: str) -> str | None:
    """
    Generates an ABC notation string for a single, pre-combined 'mix' MIDI file.
    """
    us = environment.UserSettings()
    us['directoryScratch'] = '/tmp'
    temp_dir = Path(us['directoryScratch'])
    mix_title = f"{song_title} (Mix)"
    temp_abc_path = temp_dir / f"{mix_title}.abc"

    try:
        print("\n  -> Creating combined 'Mix' ABC score...")
        cmd = ['midi2abc', mix_midi_path, '-o', str(temp_abc_path)]
        result = subprocess.run(cmd, capture_output=True, text=True, check=False)

        if result.returncode == 0 and temp_abc_path.exists():
            raw_mix_abc = temp_abc_path.read_text(encoding='utf-8')
            cleaned_mix_abc = _post_process_abc_content(raw_mix_abc, mix_title)
            print("  -> Successfully created 'Mix' ABC.")
            return cleaned_mix_abc
        else:
            print(f"  -> ERROR: midi2abc failed for combined Mix. Stderr: {result.stderr}")
            return None
    except Exception as e:
        print(f"  -> An error occurred during combined Mix ABC conversion: {e}")
        return None
    finally:
        if temp_abc_path.exists():
            os.remove(temp_abc_path)
