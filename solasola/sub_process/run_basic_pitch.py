"""
Runs the Basic Pitch model to convert an audio file to MIDI in an isolated subprocess.

This script is executed in a dedicated virtual environment (`venv_basic_pitch`)
because Basic Pitch requires an older version of NumPy (v1.x) that conflicts
with other dependencies in the main application. This isolation prevents version clashes.
"""
import argparse
import json
import sys
import traceback
from pathlib import Path

# Add a check for the numpy version to ensure the isolated environment is set up correctly.
# This ensures the isolated environment is set up correctly.
try:
    import numpy
    numpy_version = tuple(map(int, numpy.__version__.split('.')))
    if numpy_version[0] >= 2:
        raise ImportError("Basic Pitch requires NumPy v1.x, but a newer version is installed. Please check the virtual environment setup.")
except ImportError as e:
    # This block will now catch both the initial import error and our custom error.
    # We write the error to a JSON file so the main process can parse it and display a
    # user-friendly message. This is more robust than relying on parsing raw stderr text.
    parser = argparse.ArgumentParser()
    parser.add_argument("--output_path", required=True)
    args, _ = parser.parse_known_args() # Parse only the output_path we need
    
    error_info = {
        "error": "NumPy version conflict.",
        "details": str(e),
        "traceback": traceback.format_exc()
    }
    error_file_path = Path(args.output_path).with_suffix('.error.json')
    with open(error_file_path, 'w') as f:
        json.dump(error_info, f, indent=2)
    
    # Also print to stderr for immediate logging
    print(f"ERROR: {error_info['error']} - {error_info['details']}", file=sys.stderr)
    sys.exit(1)

# Now, import the rest of the libraries
from basic_pitch.inference import predict_and_save
from basic_pitch import ICASSP_2022_MODEL_PATH

def convert(audio_path_str: str, output_path_str: str):
    """
    The core MIDI conversion logic, running in an isolated process.
    """
    print(f"  -> [Basic Pitch] Starting conversion for: {Path(audio_path_str).name}")
    
    # Use the predict_and_save function from basic-pitch
    # It handles loading the audio, running inference, and saving the MIDI file.
    predict_and_save(
        audio_path_list=[audio_path_str],
        output_directory=str(Path(output_path_str).parent),
        save_midi=True,
        sonify_midi=False,
        save_model_outputs=False,
        save_notes=False,
        model_or_model_path=ICASSP_2022_MODEL_PATH,
    )
    
    # The output filename is automatically generated by basic-pitch. We need to rename it.
    # e.g., 'my_audio_basic_pitch.mid' -> 'my_audio.mid'
    generated_path = Path(output_path_str).parent / f"{Path(audio_path_str).stem}_basic_pitch.mid"
    if generated_path.exists():
        generated_path.rename(output_path_str)
        print(f"  -> [Basic Pitch] Conversion complete. Output renamed to: {Path(output_path_str).name}")
    else:
        raise FileNotFoundError(f"Basic Pitch did not generate the expected output file: {generated_path}")

def main():
    parser = argparse.ArgumentParser(description="Run Basic Pitch MIDI conversion in a separate process.")
    parser.add_argument("--audio_path", required=True, help="Path to the audio file.")
    parser.add_argument("--output_path", required=True, help="Path to save the output MIDI file.")
    args = parser.parse_args()

    try:
        convert(args.audio_path, args.output_path)
    except Exception as e:
        # Write detailed error information to a JSON file for the parent process to read.
        error_info = {
            "error": "MIDI conversion failed.",
            "details": str(e),
            "traceback": traceback.format_exc()
        }
        error_file_path = Path(args.output_path).with_suffix('.error.json')
        with open(error_file_path, 'w') as f:
            json.dump(error_info, f, indent=2)
        
        # Also print to stderr for immediate logging
        print(f"ERROR: {error_info['error']} - {error_info['details']}", file=sys.stderr)
        sys.exit(1)

if __name__ == "__main__":
    main()
